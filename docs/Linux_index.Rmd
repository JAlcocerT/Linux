---
title: "Linux made easy"
author: "JAT"
date: "Updated on: `r format(Sys.time(), '%d %B %Y')`"
output:
  html_document:
    css: styles.css
    toc: true
    toc_float: true
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, echo=FALSE} 
a = knitr::asis_output("\U2714")
```

```{r klippy, echo=FALSE, include=TRUE}
#It allows the clipboard button to be available in the html output
klippy::klippy()

#install.packages("remotes")
#remotes::install_github("rlesur/klippy")
```

# Intro

Web version of the outputs generated by the codes posted on <`r web_repo`/Linux>

Please feel free to copy, modify, distribute and suggest any further improvements on them.[^1]
Due to the increasing importance of containerized application running on Docker, there will be several mentions on this page to my guide on docker: <`r web_hosted`/docker/>



# Debian based distros:

Tested with Ubuntu, Elementary OS, Zorin OS (or Raspbian OS were applicable for ARM).



## Regular apps installations

Ever wondered about using linux as a regular OS, but afraid of making tedious installations of all your favorite programs, even games?

Those time consuming tasks can be avoided simpky with the use of the commands [on this repo](`r web_repo`/Linux/blob/main/Ubuntu%20installations%20bash).


The list includes, among others: VLC, blender, photoscape, octave, discord, steam and virtualbox - ALL WITH A SINGLE COMMAND.

Option 1:

If you would like to install all the programs listed there:


```{r, include=TRUE, eval=FALSE, class.source=".TheCode"}
wget  -cO - https://raw.githubusercontent.com/jalcocert/Linux/main/Ubuntu%20installations%20bash > apps-install-bash.sh && chmod 775 apps-install-bash.sh && sudo ./apps-install-bash.sh
```


Option 2:

If you are interested only in a partial installation of all the apps contained in the mentioned script, you can download it and delete the undesired parts before executing it with the following commands:


```{r, include=TRUE, eval=FALSE, class.source=".TheCode"}
wget  -cO - https://raw.githubusercontent.com/jalcocert/Linux/main/Ubuntu%20installations%20bash > apps-install-bash.sh
```

edit the file, if desired through the command line with:

```{r, include=TRUE, eval=FALSE, class.source=".TheCode"}
sudo nano apps-install-bash.sh

```

Useful apps:

```{r, include=TRUE, eval=FALSE, class.source=".TheCode"}
sudo apt install dnsutils
#nslookup google.com
```


## Secure your distro

Check your system's version with:



### Schedule Crontab tasks

Open crontab:

```{r, include=TRUE, eval=FALSE, class.source=".TheCode"}
crontab -e
```

Update it every midnight and every restart:

```{r, include=TRUE, eval=FALSE, class.source=".TheCode"}
0 0 * * * sudo apt update && sudo apt upgrade
@reboot sudo apt update && sudo apt upgrade
```

If your script isn't executing, check the system log for cron events:
grep cron /var/log/syslog

If you'd wish to view your scheduled tasks without editing you can use the command:

```{r, include=TRUE, eval=FALSE, class.source=".TheCode"}
crontab -l 
```

##### **Last time tested on Sept 2021 `r a`**


### Setup fail2ban
 
```{r, include=TRUE, eval=FALSE, class.source=".TheCode"}
 #fail2ban
sudo apt-get install -y \
apt-transport-https \
ca-certificates \
curl \
gnupg2 \
vim \
fail2ban \
ntfs-3g
```

Then: 

```{r, include=TRUE, eval=FALSE, class.source=".TheCode"}
sudo cp /etc/fail2ban/jail.conf /etc/fail2ban/jail.local && #copying it to edit
sudo nano /etc/fail2ban/jail.local
```

Add this to the file to ban for 24h if retry +3 times:

```{r, include=TRUE, eval=FALSE, class.source=".TheCode"}
bantime = 86400
port    = ssh
logpath = %(sshd_log)s
backend = %(sshd_backend)s
maxretry = 3
```

```{r, include=TRUE, eval=FALSE, class.source=".TheCode"}
sudo service fail2ban restart &&
sudo nano /var/log/fail2ban.log
```
 
##### **Last time tested on Sept 2021 `r a`** 

### Create SSH keys

This will make possible to log in to your linux server without typing a password when both computers have the same key files.

In combination with fail2ban described before, it makes the brutte-force attacks to loose sense with your server.
 

### Firewall setup (ufw)
 
sudo ss -tupln #ports in use

```{r, include=TRUE, eval=FALSE, class.source=".TheCode"}
sudo apt install ufw && #ufw
sudo ufw status &&
sudo ufw allow 22 && #allow ssh
sudo ufw enable &&
sudo ufw status &&
sudo ufw reload #restart it
```

sudo ufw allow 717 #example to allow conexion

Typical ports that are used: 22 for ssh, 443 for https, 80 for http

##### **Last time tested on Sept 2021 `r a`**


### Create users

```{r, include=TRUE, eval=FALSE, class.source=".TheCode"}
#simple:
useradd pruebecita
#with sudo rights:
useradd -g users -G sudo -s /bin/bash -m -c "Your name" user_desired_name
#without sudo rights:
useradd -g user -s /bin/bash -m -c "Your name" user_desired_name
```

To make the home folders only visible but the specific users, just do:

```{r, include=TRUE, eval=FALSE, class.source=".TheCode"}
chmod -R go-rwx /home/user_name_1
chmod -R go-rwx /home/user_name_2
chmod -R go-rwx /home/user_name_3

```

##### Last time tested on Oct 2021 `r a`

### Check devices in local network

```{r, include=TRUE, eval=FALSE, class.source=".TheCode"}
sudo apt install nast nmap \
sudo nast -m
```

or

```{r, include=TRUE, eval=FALSE, class.source=".TheCode"}
nmap -sP 192.168.1.0/24 | grep "scan"
```

## Create your own mount points

Lets first check the storages connected to the machine and identify their current path:
```{r, include=TRUE, eval=FALSE, class.source=".TheCode"}
sudo fdisk -l
```


With this information we can create an automount entry in fstab:
```{r, include=TRUE, eval=FALSE, class.source=".TheCode"}
sudo mkdir /mnt/data_mounted \
mount /dev/sdb1 /mnt/data_mounted/ #example
```

Depending on the file system, this might be needed:
```{r, include=TRUE, eval=FALSE, class.source=".TheCode"}
mount -t ntfs /dev/sdb1 /mnt/data_mounted
```

If we know the UUID of the device, we can simply:

```{r, include=TRUE, eval=FALSE, class.source=".TheCode"}
sudo mount UUID=92C269FAC269E2C9 /mnt/data_mounted
```

To do it automatically for a specific external device that we would have we need to find the UUID (Universal Unique Identifier) of the particular drive:

Option 1:
```{r, include=TRUE, eval=FALSE, class.source=".TheCode"}
sudo blkid | grep /dev/sda2 | grep UUID= #example
```

Check what is mounted and where with:
```{r, include=TRUE, eval=FALSE, class.source=".TheCode"}
df -h
```

lets add the automount entry in:

```{r, include=TRUE, eval=FALSE, class.source=".TheCode"}
sudo nano /etc/fstab
#UUID=14D82C19D82BF81E_example /mnt/data_mounted    auto nosuid,nodev,nofail,x-gvfs-show 0 0
```

Then we have to simply execute to mount as per our guidelines:
```{r, include=TRUE, eval=FALSE, class.source=".TheCode"}
sudo mount -a
```

Always remember to unmount your external storeges safely with:
```{r, include=TRUE, eval=FALSE, class.source=".TheCode"}
sudo umount /my_volume
```

Option 2:
Another option would be to set a cron task with:

```{r, include=TRUE, eval=FALSE, class.source=".TheCode"}
@reboot mount /dev/sdb1 /mnt/data_mounted/ #example
```


## Create custom aliases 
 
Lets edit this file:

```{r, include=TRUE, eval=FALSE, class.source=".TheCode"}
nano ~/.bash_aliases
```

Add this line to know your public ip address by typing myip on the terminal:
```{r, include=TRUE, eval=FALSE, class.source=".TheCode"}
alias myip='curl ipinfo.io/ip' #public ip address
```
Use this command to be able to use the new alias already in the current session
```{r, include=TRUE, eval=FALSE, class.source=".TheCode"}
source ~/.bashrc
```

Personally, I have a file saved with all my alias ready right here, which i simply have to download and my favourite alias will be set in any server with this simple command:

```{r, include=TRUE, eval=FALSE, class.source=".TheCode"}
tbd
```

##### **Last time tested on Sept 2021 `r a`**

## Install GIT and sync your repos
 
```{r, include=TRUE, eval=FALSE, class.source=".TheCode"}
 sudo apt install git &&
 git clone https://github.com/jalcocert/RPi.git &&
 cd RPi &&
 git pull #to make sure its up to date (a cron task could be scheduled)
```

If you want to add a cron task for this, simply edit, as explained:

```{r, include=TRUE, eval=FALSE, class.source=".TheCode"}
0 0 * * * cd RPi && git pull
@reboot cd RPi && git pull
```


## VPN Setup



### Tailscale


To install a home working VPN, the easiest way is to use Tailscale and pair our devices, lets install it with:

```{r, include=TRUE, eval=FALSE, class.source=".TheCode"}
sudo apt-get install apt-transport-https &&
curl -fsSL https://pkgs.tailscale.com/stable/raspbian/buster.gpg | sudo apt-key add - &&
curl -fsSL https://pkgs.tailscale.com/stable/raspbian/buster.list | sudo tee /etc/apt/sources.list.d/tailscale.list &&
sudo apt-get update &&
sudo apt-get install tailscale &&
sudo tailscale up &&
tailscale ip -4 #get the ip 

#sudo tailscale logout
#sudo tailscale down
```
 
#To force all the traffic to go through the device, Port forwarding is needed:

```{r, include=TRUE, eval=FALSE, class.source=".TheCode"}
echo 'net.ipv4.ip_forward = 1' | sudo tee -a /etc/sysctl.conf &&
echo 'net.ipv6.conf.all.forwarding = 1' | sudo tee -a /etc/sysctl.conf &&
sudo sysctl -p /etc/sysctl.conf &&
sudo tailscale down
```

With this final command, the PC/RPi will be an exit node:

```{r, include=TRUE, eval=FALSE, class.source=".TheCode"}
sudo tailscale up --advertise-exit-node
```

Remember to allow as admin in the tailscale network this machine as exit node as well. In review route settings -> use as exit node.

##### **Last time tested on Oct 2021 `r a`**




## Docker

To install docker, docker compose and portainer, simply copy the following code chunks in your terminal:


Option 1:

This first chunk is valid only for 64 bits processors (not ARM)
```{r, include=TRUE, eval=FALSE, class.source=".TheCode"}
### INSTALL DOCKER 

sudo apt update & sudo apt upgrade -y & \
sudo apt install apt-transport-https ca-certificates curl software-properties-common -y & \
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - & \
sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable" & \

sudo apt update -y & \

apt-cache policy docker-ce & \
sudo apt install docker-ce & \

sudo systemctl status docker 
```

This one will work normally in ARM as well:
```{r, include=TRUE, eval=FALSE, class.source=".TheCode"}
## INSTALL DOCKER COMPOSE

sudo apt install docker-compose -y \

## INSTALL PORTAINER
sudo docker run -d -p 8000:8000 -p 9000:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce

#Test that docker works with this image:
#docker run hello-world
#sudo docker-compose version
```

Option 2:

On [this github repository](`web_repo`/docker/blob/main/1%20Docker%20%26%20%20Docker%20compose%20%26%20Portainer), there is the possibility to download and install directly a bash program with all the previous commands by typing only this on the terminal:

```{r, include=TRUE, eval=FALSE, class.source=".TheCode"}
wget  -cO - https://raw.githubusercontent.com/jalcocert/docker/main/1%20Docker%20%26%20%20Docker%20compose%20%26%20Portainer > docker_install.sh && chmod 775 docker_install.sh && sudo ./docker_install.sh
```




## RPi projects


The Raspberry Pi is a tiny and affordable computer (ARM based) that you can use to learn programming through fun, practical projects. 

It can run Linux distros like: Debian, OpenMediaVault or most commonly Raspbian OS.

Check out some recommended setups and projects on [my RPi repo](`r web_repo`/RPi/)


# Arch based distros:

Testing with Garuda Linux.


```{r, include=FALSE, eval=FALSE, class.source=".TheCode"}

[^1]: Check out other projects from [my main page](https://jalcocert.github.io/jalcocert/)


```